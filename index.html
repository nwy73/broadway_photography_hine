<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Broadway Vector Tiles</title>

    <!-- MapLibre + fonts -->
    <link href="https://unpkg.com/maplibre-gl@^5.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Jacques+Francois&display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css2?family=Fraunces:wght@400;700&display=swap" rel="stylesheet" />

    <style>
      /* =====================================================
         Design tokens / base
      ====================================================== */
      :root {
        --bg: #f9f7f1;
        --ink: #333;
        --ink-muted: #555;
        --panel: #e6d1aa;
        --shadow-sm: 2px 2px 6px rgba(0, 0, 0, 0.1);
        --shadow-lg: 0 0 12px rgba(0, 0, 0, 0.3);
        --radius: 8px;
        --gap: 12px;
      }

      @font-face {
        font-family: "CGHine";
        src: url("./font/CgHine-Regular.ttf") format("truetype");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: var(--bg);
      }

      /* =====================================================
         Map layout
      ====================================================== */
      #map-container,
      #map {
        position: absolute;
        inset: 0;
      }

      /* =====================================================
         Control panel (sliders + toggles)
      ====================================================== */
      #slider-container {
        font-family: "Jacques Francois", serif;
        background-color: var(--bg);
        border: 1px solid #ccc;
        padding: 12px;
        width: 280px;
        box-shadow: var(--shadow-sm);
        border-radius: 6px;
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 2;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      #opacity-labels,
      #slider-container label {
        font-size: 0.9em;
        color: var(--ink-muted);
      }

      #opacity-labels {
        display: flex;
        justify-content: space-between;
        margin-bottom: 6px;
        user-select: none;
      }

      input[type="range"] {
        width: 100%;
      }

      #time-year {
        font-size: 0.9em;
        margin-left: 8px;
        color: var(--ink-muted);
      }

      /* =====================================================
         MapLibre popups
      ====================================================== */
      .maplibregl-popup-content {
        max-height: calc(100vh - 40px);
        overflow-y: auto;
      }
      .maplibregl-popup {
        max-width: 300px;
      }

      /* =====================================================
         Fullscreen overlay (image viewer)
      ====================================================== */
      #fullscreen-overlay {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 9999;
        display: none; /* toggled via JS */
        justify-content: center;
        align-items: center;
      }

      #overlay-content {
        display: flex;
        width: 90%;
        height: 90%;
        background-color: var(--bg);
        border-radius: var(--radius);
        overflow: hidden;
        box-shadow: var(--shadow-lg);
      }

      #overlay-sidebar {
        width: 30%;
        padding: 24px;
        box-sizing: border-box;
        background-color: var(--panel);
        background-image: url("png/clean-textile.png");
        background-repeat: repeat;
        font-family: "Fraunces", serif;
        color: var(--ink);
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      #overlay-title {
        font-size: 1.2em;
        line-height: 1.4;
        word-wrap: break-word;
        text-align: left;
      }

      #overlay-image-container {
        width: 70%;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #222;
        padding: 24px;
        box-sizing: border-box;
        overflow: hidden;
      }

      /* Pan/zoom target wrapper */
      #rephoto-wrap {
        position: absolute;
        inset: 12px; /* matches container padding visually */
        box-sizing: border-box;
        transform-origin: 0 0;
        touch-action: none;
        will-change: transform;
        overflow: hidden; /* keep images clipped */
      }

      /* Stacked images fill wrapper; keep full image visible */
      #rephoto-wrap img {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: contain;
        border-radius: 4px;
        transition: opacity 0.3s ease;
        user-select: none;
        -webkit-user-drag: none;
      }
      #historic-image { z-index: 1; opacity: 1; }
      #rephoto-image  { z-index: 2; opacity: 0; }

      /* Overlay close button */
      #overlay-close-btn {
        position: absolute;
        top: 16px;
        right: 16px;
        background-color: rgba(255, 255, 255, 0.9);
        border: none;
        border-radius: 50%;
        font-size: 1.2em;
        padding: 6px 10px;
        cursor: pointer;
        font-weight: bold;
        line-height: 1;
        color: #333;
        transition: background-color 0.2s;
        z-index: 9000;
      }
      #overlay-close-btn:hover { background-color: #fff; }

      #fullscreen-overlay label[for="dissolve-slider"] {
        font-size: 12px;
        margin-top: 20px;
        display: block;
      }

      /* Respect reduced motion for overlay fades/opacity transitions */
      @media (prefers-reduced-motion: reduce) {
        #rephoto-wrap img { transition: none; }
      }

      /* =====================================================
        Zoom controls (overlay)
      ====================================================== */
      #zoom-controls {
        position: absolute;
        left: 16px;
        top: 16px;
        display: flex;
        gap: 8px;
        z-index: 9001;
      }

      #zoom-controls button {
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid #ddd;
        border-radius: 6px;
        padding: 6px 10px;
        font-size: 14px;
        cursor: pointer;
        box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.1);
      }

      #zoom-controls button:hover { background: #fff; }

    </style>
  </head>

  <body>
    <!-- ============================
         Map canvas
    ============================= -->
    <div id="map-container"><div id="map"></div></div>

    <!-- ============================
         UI Panel
    ============================= -->
    <aside id="slider-container" aria-label="Map controls">
      <section id="opacity-slider">
        <div id="opacity-labels"><span>Historic Map</span><span>Contemporary Map</span></div>
        <input type="range" id="slider" min="0" max="100" value="0" />
      </section>

      <section id="time-slider">
        <label for="time-slider-input">Historic Progression of Broadway</label>
        <input type="range" id="time-slider-input" min="1776" max="1906" value="1776" step="1" />
        <span id="time-year" aria-live="polite">1776</span>
      </section>

      <section id="layer-toggle">
        <label><input type="checkbox" id="broadway-toggle" checked /> Broadway</label><br />
        <label><input type="checkbox" id="subway-toggle" /> Subway</label><br />
        <label><input type="checkbox" id="elevated-toggle" /> Elevated Train</label><br />
        <label><input type="checkbox" id="indian-trails-toggle" /> Indian Trails (Speculative)</label>
      </section>
    </aside>

    <!-- ============================
         Fullscreen Overlay
    ============================= -->
    <div id="fullscreen-overlay" role="dialog" aria-modal="true" aria-label="Historic photo viewer">
      <div id="overlay-content">
        <div id="overlay-sidebar">
          <div id="overlay-title">Photo Title Placeholder</div>
          <p style="font-size:12px;color:#555;margin:0;">Previous &larr; &rarr; Next</p>
          <div id="overlay-navigation" style="margin:0;display:flex;gap:8px;">
            <button id="prev-btn" aria-label="Previous photo">&larr;</button>
            <button id="next-btn" aria-label="Next photo">&rarr;</button>
          </div>
          <label for="dissolve-slider">Dissolve Between Historic and Rephoto</label>
          <input type="range" id="dissolve-slider" min="0" max="100" value="0" />
        </div>
        <div id="overlay-image-container">
          <button id="overlay-close-btn" aria-label="Close viewer">&times;</button>
          <div id="rephoto-wrap">
            <img id="historic-image" src="" alt="Historic" />
            <img id="rephoto-image" src="" alt="Re-photograph" />
          </div>
          <!-- Zoom toolbar -->
          <div id="zoom-controls" role="toolbar" aria-label="Image zoom controls">
            <button id="zoom-out" aria-label="Zoom out">−</button>
            <button id="zoom-in" aria-label="Zoom in">+</button>
            <button id="zoom-reset" aria-label="Reset zoom">Reset</button>
          </div>
        </div>
      </div>
    </div>

    <!-- ============================
         Scripts
    ============================= -->
    <script src="https://unpkg.com/maplibre-gl@^5.6.2/dist/maplibre-gl.js"></script>
    <script src="https://unpkg.com/@panzoom/panzoom/dist/panzoom.min.js"></script>
    <script>
      /* =====================================================
         DOM references
      ====================================================== */
      const overlay = document.getElementById("fullscreen-overlay");
      const container = document.getElementById("overlay-image-container");
      const wrapper = document.getElementById("rephoto-wrap");
      const historic = document.getElementById("historic-image");
      const rephoto = document.getElementById("rephoto-image");
      const dissolve = document.getElementById("dissolve-slider");

      const timeSlider = document.getElementById("time-slider-input");
      const timeYear = document.getElementById("time-year");
      const slider = document.getElementById("slider");

      const broadwayToggle = document.getElementById("broadway-toggle");
      const subwayToggle = document.getElementById("subway-toggle");
      const elevatedToggle = document.getElementById("elevated-toggle");
      const indianTrailsToggle = document.getElementById("indian-trails-toggle");
      
      // Zoom control refs
      const zoomInBtn = document.getElementById("zoom-in");
      const zoomOutBtn = document.getElementById("zoom-out");
      const zoomResetBtn = document.getElementById("zoom-reset");

      /* =====================================================
         Panzoom (single instance)
         - Start contained to ensure first fit stays in bounds
         - Release containment on user interaction
      ====================================================== */
      const pz = Panzoom(wrapper, { maxScale: 4, contain: "inside" });
      let containReleased = false;

      const enforceContain = () => {
        containReleased = false;
        pz.setOptions({ contain: "inside" });
      };
      const releaseContain = () => {
        if (containReleased) return;
        containReleased = true;
        pz.setOptions({ contain: false });
      };

      // Wheel zoom & drag start release the initial containment
      wrapper.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          releaseContain();
          pz.zoomWithWheel(e);
        },
        { passive: false }
      );
      wrapper.addEventListener("pointerdown", releaseContain);

      // --- Zoom buttons ---
      const MAX_SCALE = 4;   // keep in sync with Panzoom's maxScale
      const MIN_SCALE = 1;   // we lock min to 1 so "fit" never gets smaller

      function getCurrentScale() {
        // Prefer Panzoom's API if available
        if (typeof pz.getScale === "function") return pz.getScale();
        // Fallback: read the current CSS transform matrix on the wrapper
        const m = new DOMMatrixReadOnly(getComputedStyle(wrapper).transform);
        return m.a || 1;
      }

      function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }

      function zoomBy(factor) {
        // Allow the user to move outside initial bounds once they start zooming
        releaseContain();

        const current = getCurrentScale();
        const next = clamp(current * factor, MIN_SCALE, MAX_SCALE);

        // Zoom toward the center of the container (feels natural)
        const rect = container.getBoundingClientRect();
        const point = { clientX: rect.left + rect.width / 2, clientY: rect.top + rect.height / 2 };

        if (typeof pz.zoomToPoint === "function") {
          pz.zoomToPoint(next, point);
        } else if (typeof pz.zoom === "function") {
          // Fallback: simple zoom; Panzoom will keep current center
          pz.zoom(next, { animate: true });
        }
      }

      // Wire up buttons
      zoomInBtn.addEventListener("click", () => zoomBy(1.25));
      zoomOutBtn.addEventListener("click", () => zoomBy(1 / 1.25));
      zoomResetBtn.addEventListener("click", () => { enforceContain(); resetToFit(); });

      /* =====================================================
         Map setup
      ====================================================== */
      const map = new maplibregl.Map({
        container: "map",
        style: "assets/styles/style.json",
        center: [-73.96, 40.79],
        zoom: 11,
      });
      map.addControl(new maplibregl.NavigationControl(), "top-left");

      // Broadway history for filtering
      let originalGeoJsonData = null;
      // Photo features + current index
      let photoFeatures = [];
      let currentPhotoIndex = -1;

      /* =====================================================
         Small utilities
      ====================================================== */
      const raf = () => new Promise((r) => requestAnimationFrame(r));

      /**
       * Load an SVG and register it as a MapLibre image using a canvas bitmap.
       */
      async function loadSVGAsImage(name, url) {
        const response = await fetch(url);
        const svgText = await response.text();
        const img = new Image();
        const svgBlob = new Blob([svgText], { type: "image/svg+xml" });
        const urlObj = URL.createObjectURL(svgBlob);

        return new Promise((resolve, reject) => {
          img.onload = async () => {
            // Prefer square canvas; derive from viewBox if present.
            const viewBoxMatch = svgText.match(/viewBox="([\d.\s]+)"/);
            let size = 64;
            if (viewBoxMatch) {
              const [, , w, h] = viewBoxMatch[1].split(" ").map(Number);
              size = Math.max(w, h) || 64;
            }
            const canvas = document.createElement("canvas");
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0, size, size);
            const bitmap = await createImageBitmap(canvas);
            if (!map.hasImage(name)) map.addImage(name, bitmap, { pixelRatio: 1 });
            URL.revokeObjectURL(urlObj);
            resolve();
          };
          img.onerror = reject;
          img.src = urlObj;
        });
      }

      /**
       * Filter Broadway-history features by active year.
       */
      function filterByYear(year) {
        if (!originalGeoJsonData)
          return { type: "FeatureCollection", features: [] };
        const features = originalGeoJsonData.features.filter((f) => {
          const { syear, eyear } = f.properties;
          return year >= syear && year <= eyear;
        });
        return { type: "FeatureCollection", features };
      }

      /**
       * Size the panzoom wrapper to the container’s inner (padded) content box.
       * The wrapper is absolutely positioned with `inset: 12px`; this function
       * keeps its CSS-driven sizing in sync if container padding changes or when
       * we need explicit width/height during measurements.
       */
      function sizeWrapperToContainerBox() {
        const rect = container.getBoundingClientRect();
        // Subtract the visual inset (12px on each side) to match CSS
        const inset = 12 * 2;
        const w = Math.max(0, rect.width - inset);
        const h = Math.max(0, rect.height - inset);
        wrapper.style.width = w + "px";
        wrapper.style.height = h + "px";
      }

      /**
       * Reset view to scale=1 and x/y=0 using Panzoom's public API.
       * Also lock the minimum so the user can't zoom out smaller than fit.
       */
      function resetToFit() {
        pz.setOptions({ minScale: 1 });
        if (typeof pz.reset === "function") {
          pz.reset({ animate: false });
        } else {
          // Fallback for older builds: manually set zoom and pan
          if (typeof pz.zoom === "function") pz.zoom(1, { animate: false });
          if (typeof pz.pan === "function") pz.pan(0, 0, { animate: false });
        }
      }

      /**
       * Optional: nudge the image to ensure its natural bounds are centered
       * after fonts/layout settle. Left as a no-op but preserved for future
       * fine-tuning. Safe to call repeatedly.
       */
      function nudgeToImageRect() {
        // Intentionally empty. Placeholder for future fit heuristics.
      }

      // Convenience: do a full recenter sequence now
      function centerNow() {
        sizeWrapperToContainerBox();
        resetToFit();
      }

      /**
       * Open overlay and perform a stable sequence of fit + nudges.
       * We allow layout to settle (scrollbars/fonts) before measuring.
       */
      async function openOverlayStable() {
        overlay.style.display = "flex";
        // Removing page scrollbars can change viewport height; wait for layout to settle
        document.documentElement.style.overflow = "hidden";
        overlay.getBoundingClientRect(); // force style & layout flush
        await raf();
        await raf(); // 2 frames => stable measurements
      }

      async function waitImageReady(img) {
        if (img.decode) {
          try { await img.decode(); } catch {}
        } else if (!img.complete) {
          await new Promise((res) => img.addEventListener("load", res, { once: true }));
        }
        await raf(); // ensure final painted size is measurable
      }

      /**
       * Create a styled popup DOM node with optional clickable thumbnail.
       */
      function buildPhotoPopupDom({ thumbUrl, fullUrl, title, onThumbClick }) {
        const popupContainer = document.createElement("div");
        Object.assign(popupContainer.style, {
          maxWidth: "300px",
          fontFamily: "'Fraunces', serif",
          textAlign: "left",
          lineHeight: "1.3",
          backgroundColor: getComputedStyle(document.documentElement).getPropertyValue("--bg") || "#f9f7f1",
          padding: "8px",
          borderRadius: "6px",
          boxShadow: "2px 2px 6px rgba(0,0,0,0.1)",
        });

        const img = new Image();
        img.src = thumbUrl;
        Object.assign(img.style, {
          width: "100%",
          height: "auto",
          borderRadius: "4px",
          cursor: fullUrl ? "pointer" : "default",
        });

        img.onload = () => {
          popupContainer.appendChild(img);
          if (fullUrl && typeof onThumbClick === "function") {
            img.addEventListener("click", (e) => {
              e.preventDefault();
              e.stopPropagation();
              onThumbClick();
            });
          }

          const titleDiv = document.createElement("div");
          Object.assign(titleDiv.style, {
            marginTop: "4px",
            fontSize: "12px",
            color: "#333",
            wordWrap: "break-word",
            overflowWrap: "break-word",
          });
          titleDiv.textContent = '"' + title + '"' || "";
          popupContainer.appendChild(titleDiv);
        };

        return popupContainer;
      }

      /**
       * Zoom the map to the current photo and show its popup (after viewer close).
       */
      function zoomMapToCurrentAndShowPopup() {
        const feature = photoFeatures[currentPhotoIndex];
        if (!feature) return;

        map.easeTo({ center: feature.geometry.coordinates, duration: 800, zoom: 14 });

        const thumbUrl = feature.properties.thumbs || "";
        const fullUrl = feature.properties.full || "";
        const title = feature.properties.title || "";

        const popupDom = buildPhotoPopupDom({
          thumbUrl,
          fullUrl,
          title,
          onThumbClick: () => {
            if (window.currentPopup) {
              window.currentPopup.remove();
              window.currentPopup = null;
            }
            updateOverlayByIndex(currentPhotoIndex);
          },
        });

        const popup = new maplibregl.Popup({ offset: 15, closeOnClick: true })
          .setLngLat(feature.geometry.coordinates)
          .setDOMContent(popupDom)
          .addTo(map);
        window.currentPopup = popup;
      }

      /**
       * Load a photo by index and show overlay with robust recentering.
       */
      async function updateOverlayByIndex(index) {
        if (index < 0 || index >= photoFeatures.length) return;

        const feature = photoFeatures[index];
        currentPhotoIndex = index;

        // Reset pan/zoom and containment state
        pz.reset();
        containReleased = false;
        enforceContain();

        // Update images + title; guard for missing URL
        const fullUrl = feature.properties.full || "";
        if (!fullUrl) return; // don’t open empty overlay
        const title = feature.properties.title || "";
        historic.src = fullUrl;
        rephoto.src = "img/rephotos/" + fullUrl.split("/").pop();
        document.getElementById("overlay-title").textContent = title;
        // Add double quotes to title if not already present
        if (!title.startsWith('"') && !title.endsWith('"')) {
          document.getElementById("overlay-title").textContent = `"${title}"`;
        }

        // Reset dissolve
        dissolve.value = 0;
        historic.style.opacity = 1;
        rephoto.style.opacity = 0;

        // 1) Open overlay and let layout settle
        await openOverlayStable();

        // 2) Ensure the historic image has decoded/painted so its rect is accurate
        await waitImageReady(historic);

        // 3) Match wrapper to container inner box then center + (optional) nudge
        sizeWrapperToContainerBox();
        resetToFit();
        nudgeToImageRect();

        // 4) One more frame for straggling layout (fonts, etc.)
        await raf();
        sizeWrapperToContainerBox();
        resetToFit();
        nudgeToImageRect();
      }

      /* =====================================================
         Overlay UI listeners
      ====================================================== */
      // Crossfade the stacked images based on the dissolve slider
      dissolve.addEventListener("input", (e) => {
        const v = +e.target.value / 100;
        rephoto.style.opacity = v;
        historic.style.opacity = 1 - v;
      });

      // Close the overlay, restore page scroll, and re-open the map popup
      document.getElementById("overlay-close-btn").addEventListener("click", () => {
        overlay.style.display = "none";
        document.documentElement.style.overflow = ""; // restore scroll
        pz.reset();
        containReleased = false;
        zoomMapToCurrentAndShowPopup();
      });

      // Fit again on resize while overlay is visible (debounced to next frame)
      let resizeRaf = 0;
      window.addEventListener("resize", () => {
        if (overlay.style.display === "none") return;
        cancelAnimationFrame(resizeRaf);
        resizeRaf = requestAnimationFrame(() => {
          centerNow();
          nudgeToImageRect();
        });
      });

      // Prev/Next navigation in overlay
      document.getElementById("prev-btn").addEventListener("click", () => {
        if (currentPhotoIndex > 0) updateOverlayByIndex(currentPhotoIndex - 1);
      });
      document.getElementById("next-btn").addEventListener("click", () => {
        if (currentPhotoIndex < photoFeatures.length - 1)
          updateOverlayByIndex(currentPhotoIndex + 1);
      });

      /* =====================================================
         Map content
      ====================================================== */
      map.on("load", async () => {
        // When the photos source finishes, cache features for indexing
        map.on("sourcedata", (e) => {
          if (
            e.sourceId === "photos" &&
            e.isSourceLoaded &&
            map.getSource("photos") &&
            map.getSource("photos")._data
          ) {
            photoFeatures = map.getSource("photos")._data.features || [];
          }
        });

        // Panel defaults
        timeSlider.value = 1776;
        timeYear.textContent = "1776";
        slider.value = 0;

        /* -----------------------------
           Base raster (Voyager)
        ------------------------------*/
        map.addSource("voyager", {
          type: "raster",
          tiles: [
            "https://basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png",
          ],
          tileSize: 256,
        });
        map.addLayer(
          {
            id: "voyager-raster-layer",
            type: "raster",
            source: "voyager",
            paint: { "raster-opacity": 0 }, // starts hidden; slider reveals it
          },
          "paper-fibers-layer"
        );

        /* -----------------------------
           Broadway history: fetch & filter by year
        ------------------------------*/
        fetch("overlays/Broadway_History.geojson")
          .then((r) => r.json())
          .then((data) => {
            originalGeoJsonData = data;
            const filtered = filterByYear(+timeSlider.value);
            map.addSource("broadway-history", { type: "geojson", data: filtered });
            map.addLayer({
              id: "broadway-history-layer",
              type: "line",
              source: "broadway-history",
              layout: { visibility: "visible" },
              paint: {
                "line-color": "#8B5E3C",
                "line-width": 3,
                "line-opacity": 1,
              },
            });
          });

        /* -----------------------------
           Hover popup for lines/stations
        ------------------------------*/
        const hoverPopup = new maplibregl.Popup({
          closeButton: false,
          closeOnClick: false,
          offset: 10,
          className: "hover-tooltip",
        });

        /* -----------------------------
           Indian Trails
        ------------------------------*/
        map.addSource("indian-trails", { type: "geojson", data: "overlays/indian-trails.geojson" });
        map.addLayer({
          id: "indian-trails-layer",
          type: "line",
          source: "indian-trails",
          layout: { visibility: "none" },
          paint: {
            "line-color": [
              "case",
              ["boolean", ["feature-state", "hover"], false],
              "#D8A903",
              "#003153",
            ],
            "line-width": 2,
            "line-opacity": 0.7,
            "line-dasharray": [2, 4],
          },
        });

        /* -----------------------------
           Elevated train
        ------------------------------*/
        map.addSource("elevated-train", { type: "geojson", data: "overlays/elevated-train.geojson" });
        map.addSource("elevated-stations", { type: "geojson", data: "overlays/elevated-stations.geojson" });
        map.addLayer({
          id: "elevated-train-layer",
          type: "line",
          source: "elevated-train",
          layout: { visibility: "none" },
          paint: {
            "line-color": [
              "case",
              ["boolean", ["feature-state", "hover"], false],
              "#D8A903",
              "#A67B5B",
            ],
            "line-width": 2,
          },
        });
        map.addLayer({
          id: "elevated-stations-layer",
          type: "circle",
          source: "elevated-stations",
          layout: { visibility: "none" },
          paint: {
            "circle-radius": 4,
            "circle-color": [
              "case",
              ["boolean", ["feature-state", "hover"], false],
              "#D8A903",
              "#4C6A72",
            ],
            "circle-stroke-color": "#f9f7f1",   // was "var(--bg)"
            "circle-stroke-width": 1,
          },
        });

        /* -----------------------------
           Subway
        ------------------------------*/
        map.addSource("subway-lines", { type: "geojson", data: "overlays/subway.geojson" });
        map.addSource("subway-stations", { type: "geojson", data: "overlays/subway-stations.geojson" });
        map.addLayer({
          id: "subway-lines-layer",
          type: "line",
          source: "subway-lines",
          layout: { visibility: "none" },
          paint: {
            "line-color": [
              "case",
              ["boolean", ["feature-state", "hover"], false],
              "#D8A903",
              "#732E2E",
            ],
            "line-width": 2,
          },
        });
        map.addLayer({
          id: "subway-stations-layer",
          type: "circle",
          source: "subway-stations",
          layout: { visibility: "none" },
          paint: {
            "circle-radius": 4,
            "circle-color": [
              "case",
              ["boolean", ["feature-state", "hover"], false],
              "#D8A903",
              "#8A9A5B",
            ],
            "circle-stroke-color": "#f9f7f1",   // was "var(--bg)"
            "circle-stroke-width": 1,
          },
        });

        // Hover state keys for feature-state toggling
        const hoverState = {
          hoveredIndianTrailId: null,
          hoveredElevatedId: null,
          hoveredElevatedStationId: null,
          hoveredSubwayId: null,
          hoveredSubwayStationId: null,
        };
        const hoverKeyForLayer = (layerId) =>
          layerId.includes("indian")
            ? "hoveredIndianTrailId"
            : layerId.includes("elevated-stations")
            ? "hoveredElevatedStationId"
            : layerId.includes("elevated")
            ? "hoveredElevatedId"
            : layerId.includes("subway-stations")
            ? "hoveredSubwayStationId"
            : "hoveredSubwayId";

        /** Generic hover interaction with feature-state + tooltip */
        function addHover(layerId, sourceId, nameProp = "name") {
          map.on("mousemove", layerId, (e) => {
            const fs = map.queryRenderedFeatures(e.point, { layers: [layerId] });
            if (!fs.length) {
              map.getCanvas().style.cursor = "";
              hoverPopup.remove();
              return;
            }
            const f = fs[0];
            const key = hoverKeyForLayer(layerId);
            if (hoverState[key] !== f.id) {
              if (hoverState[key] !== null) {
                map.setFeatureState(
                  { source: sourceId, id: hoverState[key] },
                  { hover: false }
                );
              }
              hoverState[key] = f.id;
              map.setFeatureState({ source: sourceId, id: f.id }, { hover: true });
            }
            hoverPopup
              .setLngLat(e.lngLat)
              .setHTML(`<strong>${f.properties[nameProp] || "Unknown"}</strong>`)
              .addTo(map);
            map.getCanvas().style.cursor = "pointer";
          });

          map.on("mouseleave", layerId, () => {
            const key = hoverKeyForLayer(layerId);
            if (hoverState[key] !== null) {
              map.setFeatureState(
                { source: sourceId, id: hoverState[key] },
                { hover: false }
              );
              hoverState[key] = null;
            }
            map.getCanvas().style.cursor = "";
            hoverPopup.remove();
          });
        }

        addHover("indian-trails-layer", "indian-trails", "name");
        addHover("elevated-train-layer", "elevated-train", "name");
        addHover("elevated-stations-layer", "elevated-stations", "name");
        addHover("subway-lines-layer", "subway-lines", "name");
        addHover("subway-stations-layer", "subway-stations", "name");

        /* -----------------------------
           Camera icons + photos layer
        ------------------------------*/
        await loadSVGAsImage("camera", "svg/camera.svg");

        map.addSource("photos", { type: "geojson", data: "overlays/photos.geojson" });

        map.addLayer({
          id: "photos-layer",
          type: "symbol",
          source: "photos",
          layout: {
            "icon-image": "camera",
            "icon-size": ["interpolate", ["linear"], ["zoom"], 10, 0.02, 15, 0.05],
            "icon-allow-overlap": false,
            "icon-anchor": "center",
            "icon-rotate": ["+", ["get", "orientation"], 180],
          },
          paint: {
            "icon-opacity": [
              "case",
              ["boolean", ["feature-state", "hover"], false],
              0.5,
              1,
            ],
          },
        });

        // Hover effect (fade icon)
        let hoveredPhotoId = null;
        map.on("mousemove", "photos-layer", (e) => {
          const fs = map.queryRenderedFeatures(e.point, { layers: ["photos-layer"] });
          if (!fs.length) {
            if (hoveredPhotoId !== null) {
              map.setFeatureState({ source: "photos", id: hoveredPhotoId }, { hover: false });
              hoveredPhotoId = null;
            }
            map.getCanvas().style.cursor = "";
            return;
          }
          const f = fs[0];
          if (hoveredPhotoId !== f.id) {
            if (hoveredPhotoId !== null)
              map.setFeatureState({ source: "photos", id: hoveredPhotoId }, { hover: false });
            hoveredPhotoId = f.id;
            map.setFeatureState({ source: "photos", id: hoveredPhotoId }, { hover: true });
          }
          map.getCanvas().style.cursor = "pointer";
        });
        map.on("mouseleave", "photos-layer", () => {
          if (hoveredPhotoId !== null) {
            map.setFeatureState({ source: "photos", id: hoveredPhotoId }, { hover: false });
            hoveredPhotoId = null;
          }
          map.getCanvas().style.cursor = "";
        });

        // Click photo icon → popup with thumbnail; click thumbnail → open overlay
        map.on("click", "photos-layer", (e) => {
          const feature = e.features[0];
          const thumbUrl = feature.properties.thumbs || "";
          const fullUrl = feature.properties.full || "";
          const title = feature.properties.title || "";

          currentPhotoIndex = photoFeatures.findIndex((f) => f.id === feature.id);
          if (window.currentPopup) window.currentPopup.remove();

          const popupDom = buildPhotoPopupDom({
            thumbUrl,
            fullUrl,
            title,
            onThumbClick: () => {
              if (window.currentPopup) {
                window.currentPopup.remove();
                window.currentPopup = null;
              }
              // Give the map/popup DOM two frames to settle before we measure/open.
              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  updateOverlayByIndex(currentPhotoIndex);
                });
              });
            },
          });

          const popup = new maplibregl.Popup({ offset: 15, closeOnClick: true })
            .setLngLat(feature.geometry.coordinates)
            .setDOMContent(popupDom)
            .addTo(map);
          window.currentPopup = popup;
        });

        /* -----------------------------
           Layer toggles
        ------------------------------*/
        const setVisibility = (ids, visible) => {
          const vis = visible ? "visible" : "none";
          ids.forEach((id) => {
            if (map.getLayer(id)) map.setLayoutProperty(id, "visibility", vis);
          });
        };
        // Initial
        setVisibility(["broadway-layer", "broadway-history-layer"], broadwayToggle.checked);
        setVisibility(["subway-lines-layer", "subway-stations-layer"], subwayToggle.checked);
        setVisibility(["elevated-train-layer", "elevated-stations-layer"], elevatedToggle.checked);
        setVisibility(["indian-trails-layer"], indianTrailsToggle.checked);
        // Change listeners
        indianTrailsToggle.addEventListener("change", () =>
          setVisibility(["indian-trails-layer"], indianTrailsToggle.checked)
        );
        broadwayToggle.addEventListener("change", () =>
          setVisibility(["broadway-layer", "broadway-history-layer"], broadwayToggle.checked)
        );
        subwayToggle.addEventListener("change", () =>
          setVisibility(["subway-lines-layer", "subway-stations-layer"], subwayToggle.checked)
        );
        elevatedToggle.addEventListener("change", () =>
          setVisibility(["elevated-train-layer", "elevated-stations-layer"], elevatedToggle.checked)
        );

        /* -----------------------------
           Opacity slider: fade historic vs contemporary (Voyager)
           - Multiplies stored opacities for layers from the 'broadway' source and
             the paper-fiber layer in your style; reveals the Voyager raster inversely.
           - All checks guard against missing/renamed layers.
        ------------------------------*/
        const originalOpacities = {};
        map.once("idle", () => {
          const style = map.getStyle();
          if (!style || !style.layers) return;
          style.layers.forEach((layer) => {
            const { id, source, type } = layer;
            // Capture opacities of your custom style layers (source === 'broadway')
            if (source === "broadway") {
              const props = {};
              if (type === "fill") props["fill-opacity"] = map.getPaintProperty(id, "fill-opacity") ?? 1;
              if (type === "line") props["line-opacity"] = map.getPaintProperty(id, "line-opacity") ?? 1;
              if (type === "symbol") {
                props["text-opacity"] = map.getPaintProperty(id, "text-opacity") ?? 1;
                props["icon-opacity"] = map.getPaintProperty(id, "icon-opacity") ?? 1;
              }
              if (Object.keys(props).length) originalOpacities[id] = props;
            }
            // Paper texture layer (from your map style)
            if (id === "paper-fibers-layer" && type === "raster") {
              originalOpacities[id] = {
                "raster-opacity": map.getPaintProperty(id, "raster-opacity") ?? 1,
              };
            }
          });

          const applyOpacity = () => {
            const multiplier = 1 - +slider.value / 100;
            Object.entries(originalOpacities).forEach(([layerId, props]) => {
              if (layerId === "voyager-raster-layer") return; // never scale the voyager layer here
              Object.entries(props).forEach(([prop, val]) =>
                map.setPaintProperty(layerId, prop, val * multiplier)
              );
            });
            if (map.getLayer("voyager-raster-layer"))
              map.setPaintProperty("voyager-raster-layer", "raster-opacity", 1 - multiplier);
          };

          applyOpacity();
          slider.addEventListener("input", applyOpacity);
        });

        /* -----------------------------
           Time slider: refilter Broadway history; auto-show if off
        ------------------------------*/
        timeSlider.addEventListener("input", () => {
          const year = +timeSlider.value;
          timeYear.textContent = String(year);
          if (map.getSource("broadway-history"))
            map.getSource("broadway-history").setData(filterByYear(year));
          if (!broadwayToggle.checked) {
            broadwayToggle.checked = true;
            setVisibility(["broadway-layer", "broadway-history-layer"], true);
          }
        });
      });
    </script>
  </body>
</html>